Search In Rotated Sorted Array这题也AC了几遍了，今天复习的时候突然脑抽，研究起哲学来了。这才发现这题原来非常的深奥。当各位看官刷题刷累了躺床上睡不着或者厕所里坐着的时候，可以抱着轻松地心态来听我说说。
首先我们来看看正确的打开方式：如图中显示了三种可能出现的情况（如果有重复值的话，那么有6种，情况过于复杂，适合用来写毕业论文，就不在这里讨论了），那么根据二分法的思维，首先判断目标值t与中点m的值的大小关系。那么当t比m大的时候，1，2两种情况t必在m右边，可以发现这两种情况m>s；而第3种情况，当t>s时在左，不然在右。写成英文的形式就是
if (t == m) return m的下标（以后就省略下标这两个字了）;
if (t > m) {
    if (m > s) {
        去左半边找;
    } else {
        if (t > s) {
            也去左半边找; 
        } else {
            只能去右半边找了;
        }
    }
}
仔细想想，发现两个去左半查找的条件其实可以合并，那样可以减少一层嵌套，让代码更加对称，强迫症患者可以少吃点药，于是代码变成
if (t == m) return m;
if (t > m) {
    if (m > s || t > s) {
        西;
    } else {
        东;
    }
} // 另一半请自行补全或参看刷题小组的劳动成果。

结果今天突然想到，为啥一定要先从t和m比起呢？为啥一定是这3个条件呢？为啥我们要刷题找工作呢？
心动不如行动，首先我就掏出笔写下每张图所有的条件：
1. s<m<e，m<t：右。m>t：左。
2. e<s<m，m<t：右。m>t && s<t：左。m>t && e>t：右。
3. m<e<s，m<t && s<t：左。m<t && e>t：右。m>t：左。
哇，这么多判断！我只要把所有不等式用and和or连起来，随便化化简就可以把这道题作对了！为啥化到最简却只有那一种形式了呢？
现在我们用一些标记来简化不等式，SM表示s<m是否为真（想歪了的面壁去），依次类推，我们发现只要四个布尔量就够了：SM, ME, MT, ST。因为当得知s<m和m>e时，是不可能发现s<e的（所以如果有重复值的话就又多了几种情况，就不要这么分析了，一旦发现m=s或m=e，立马暴力搜索去），s<e对吗只要看s<m && m<e对吗。同样，t<e则t<s是板上订丁的事儿。当时反过来，如果去掉这四个中的任意一个，则有几种可能就混在一起了，所以不能再化简。
好，看到这里一些EE出身的朋友可能已经在纸上画出了卡诺图了，一些高中数学学的好的朋友开始画文氏图了。停！我们最后是要用if和else来表示，化成最贱二项式或者阴影图于事无补啊！我们用用摩根老人家的定理就够了。用~来表示取非，则
左：SM * ME * ~MT + SM * ~ME * ~MT * ST + ~SM * ME * MT * ST + ~SM * ME * ~MT
右：SM * ME * MT + SM * ~ME * MT + SM * ~ME * ~MT * ~ST + ~SM * ME * MT * ~ST （注意因为e<s在这里都成立，所以e>t <=> s>t）
好对称啊，真爽！通过该式容易得证，只能从MT开始判断才能使if else数用的最少。
好吧这样说估计有人要打我，那我们一个一个来看：首先看SM。当SM为真时，有三种情况可以让他为右，两种为左，这怎么判断啊？！ME同理。而ST，有两项都没有出现！没出现不代表不用考虑，而是表示同时要考虑真或假两种情况，即a = ab+a(~b)。所以ST也排除了。再来看MT，MT为真时只有一种情况为左，为假时只有一种情况为右，这不是两层if就能判断了么！！
于是就回到了一开始说的那种方法：
if (MT) 
    if (~SM * ME * ST) 左; 
    else 右;
其实这里还没化到最贱。if (s > m && m < e && s < t) 这个条件可以通过摩根定理变为 if (m > s || t > s)。因为 s > m && m < e 取非以后，图上可见只有 m > s 一种情况了。

好吧，罗罗嗦嗦算了不少，结果发现还是原来的做法好，也是醉了。如果有朋友也钻了牛角尖的话，看了这篇帖子以后还是乖乖放弃吧。
